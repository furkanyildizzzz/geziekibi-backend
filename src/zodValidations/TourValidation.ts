import { PublishStatus, TourType } from 'orm/entities/tour/types';
import { z } from 'zod';
const fileSizeLimit = 5 * 1024 * 1024; // 5MB

export const TourValidationSchema = z.object({
  id: z.number().optional(), // Primary key, autogenerated
  title: z.string().min(1, { message: 'Title is required' }),
  spot: z.string().min(1, { message: 'Spot is required' }),
  body: z.string().optional(), // 'text' type is generally optional in validation
  type: z.nativeEnum(TourType).default(TourType.YURTICI),
  publishStatus: z.nativeEnum(PublishStatus).default(PublishStatus.DRAFT),
  publishDate: z
    .string()
    .refine((dateStr) => !isNaN(Date.parse(dateStr)), {
      message: 'Invalid date format',
    })
    .transform((dateStr) => new Date(dateStr))
    .optional(),
  image: z.any().optional(), // Allow any file object for image
  gallery: z.array(z.any()).optional(), // Allow an array of any file objects for gallery
  created_at: z.date().optional(), // Timestamps, typically set automatically
  updated_at: z.date().optional(),
  tags: z.array(z.object({ id: z.number() })).optional(), // Assuming `tags` are referenced by `id`
  prices: z
    .array(
      z.object({
        amount: z.number().positive({ message: 'Price amount must be positive' }),
        currency: z.string().min(1, { message: 'Currency is required' }),
      }),
    )
    .optional(),
  category: z.object({ id: z.number() }).optional(), // Category is referenced by `id`
  tourServices: z
    .array(
      z.object({
        name: z.string().min(1, { message: 'Service name is required' }),
      }),
    )
    .optional(),
});

export const TourValidationSchemaPostman = z.object({
  id: z.number().optional(), // Primary key, autogenerated
  title: z
    .string({ required_error: 'Title is required' })
    .min(3, { message: 'Title must be at least 3 character long' })
    .trim(),
  spot: z
    .string({ required_error: 'Spot is required' })
    .min(3, { message: 'Spot must be at least 3 character long' })
    .trim(),
  body: z.string().optional(), // 'text' type is generally optional in validation
  type: z.nativeEnum(TourType).default(TourType.YURTICI),
  publishStatus: z.nativeEnum(PublishStatus).default(PublishStatus.DRAFT),
  // publishDate: z
  //   .string()
  //   .refine((dateStr) => !isNaN(Date.parse(dateStr)), {
  //     message: 'Invalid date format',
  //   })
  //   .transform((dateStr) => new Date(dateStr))
  //   .optional(),
  // tags: z.string().optional(), // Assuming `tags` are referenced by `id`
  prices: z
    .array(
      z.object({
        amount: z.number().positive({ message: 'Price amount must be positive' }),
        currency: z.string().min(1, { message: 'Currency is required' }),
      }),
    )
    .optional(),
  // categoryId: z.string().refine((val) => !Number.isNaN(parseInt(val, 10)), {
  //   message: 'Expected number, received a string',
  // }), // Category is referenced by `id`
  // tourServices: z.string().optional(),
});
